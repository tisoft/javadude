##/*******************************************************************************
##*  Copyright 2008 Scott Stanchfield.
## *
## *  Licensed under the Apache License, Version 2.0 (the "License");
## *  you may not use this file except in compliance with the License.
## *  You may obtain a copy of the License at
## *
## *      http://www.apache.org/licenses/LICENSE-2.0
## *
## *  Unless required by applicable law or agreed to in writing, software
## *  distributed under the License is distributed on an "AS IS" BASIS,
## *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## *  See the License for the specific language governing permissions and
## *  limitations under the License.
## *******************************************************************************/
// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR 
// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --
package ${data.packageName};

## class definition
@javax.annotation.Generated(
    value = "com.javadude.annotation.processors.BeanAnnotationProcessor", 
    date = "${date}", 
    comments = "CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!")
${data.classAccess}abstract class ${data.className}Gen ${data.extendsClause}${data.cloneableClause} {
#foreach ($delegate in ${data.delegates})
#if ($delegate.needToDefine)
    private ${delegate.name} ${delegate.accessor};
#end
#end
    public ${data.className}Gen(${data.superConstructorArgs}) {
        ${data.superConstructorSuperCall};
#foreach ($delegate in ${data.delegates})
#if ($delegate.instantiateType)
        ${delegate.accessor} = new ${delegate.instantiateType}();
## TODO - needs better specification of instance creation - might depend on properties... lazy instantiate?
#end
#end
    }
#if ($data.cloneable)
    @Override
    public ${data.className} clone() {
        try {
            return (${data.className}) super.clone();
        } catch (CloneNotSupportedException e) {
            // will not happen
            return null;
        }
    }
#end
##
## If any bound properties exist, add PropertyChangeSupport and delegate methods for it
##
#if (${data.atLeastOneBound})
    private java.beans.PropertyChangeSupport propertyChangeSupport_ = new java.beans.PropertyChangeSupport(this);
    protected java.beans.PropertyChangeSupport getPropertyChangeSupport() {
        return propertyChangeSupport_;
    }
    public void addPropertyChangeListener(java.beans.PropertyChangeListener listener) {
        getPropertyChangeSupport().addPropertyChangeListener(listener);
    }
    public void addPropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {
        getPropertyChangeSupport().addPropertyChangeListener(propertyName, listener);
    }
    public void removePropertyChangeListener(java.beans.PropertyChangeListener listener) {
        getPropertyChangeSupport().removePropertyChangeListener(listener);
    }
    public void removePropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {
        getPropertyChangeSupport().removePropertyChangeListener(propertyName, listener);
    }
#end

#foreach ($property in ${data.properties})
## define simple properties
#if (${property.kind.isSimple()})
    private ${property.extraFieldKeywords}${property.type} ${property.name}_;
#if (${property.isReadable()})
    ${property.readerAccess}${property.extraMethodKeywords}${property.type} ${property.isGet()}${property.upperName}() {
        return ${property.name}_;
    }
#end
#if (${property.isWriteable()})
    ${property.writerAccess}${property.extraMethodKeywords}void set${property.upperName}(${property.type} value)  {
#if (${property.isNotNull()})
        if (value == null) throw new IllegalArgumentException("${property.name} cannot be null");
#end
#if (${property.isBound()})
        ${property.type} oldValue = ${property.name}_;
#end
        ${property.name}_ = value;
#if (${property.isBound()})
        getPropertyChangeSupport().firePropertyChange("${property.name}", oldValue, value);
#end
    }
#end

## define list properties
#elseif (${property.kind.isList()})
    private ${property.extraFieldKeywords}final java.util.List<${property.type}> ${property.pluralName}_ = new java.util.ArrayList<${property.type}>();
#if (${property.isReadable()})
    ${property.readerAccess}${property.extraMethodKeywords}${property.type} ${property.isGet()}${property.upperName}(int i) {
        return ${property.pluralName}_.get(i);
    }
    ${property.readerAccess}${property.extraMethodKeywords}java.util.List<${property.type}> get${property.upperPluralName}() {
        return ${property.kind.prefix}${property.pluralName}_${property.kind.suffix};
    }
    ${property.readerAccess}${property.extraMethodKeywords}boolean ${property.pluralName}Contains(${property.type} value) {
        return ${property.pluralName}_.contains(value);
    }
#end
#if (${property.isWriteable()})
    ${property.writerAccess}${property.extraMethodKeywords}void add${property.upperName}(${property.type} value) {
        if (value == null) throw new IllegalArgumentException("Cannot add null to ${property.name}");
        ${property.pluralName}_.add(value);
#if (${property.isBound()})
        getPropertyChangeSupport().firePropertyChange("${property.pluralName}", null, ${property.pluralName}_);
#end
    }
    ${property.writerAccess}${property.extraMethodKeywords}void add${property.upperName}(int i, ${property.type} value) {
        if (value == null) throw new IllegalArgumentException("Cannot add null to ${property.name}");
        ${property.pluralName}_.add(i, value);
#if (${property.isBound()})
        getPropertyChangeSupport().firePropertyChange("${property.pluralName}", null, ${property.pluralName}_);
#end
    }
    ${property.writerAccess}${property.extraMethodKeywords}void clear${property.upperPluralName}() {
        ${property.pluralName}_.clear();
#if (${property.isBound()})
        getPropertyChangeSupport().firePropertyChange("${property.pluralName}", null, ${property.pluralName}_);
#end
    }
#end

## define list properties
#elseif (${property.kind.isSet()})
    private ${property.extraFieldKeywords}final java.util.Set<${property.type}> ${property.pluralName}_ = new java.util.HashSet<${property.type}>();
#if (${property.isReadable()})
    ${property.readerAccess}${property.extraMethodKeywords}java.util.Set<${property.type}> get${property.upperPluralName}() {
        return ${property.kind.prefix}${property.pluralName}_${property.kind.suffix};
    }
    ${property.readerAccess}${property.extraMethodKeywords}boolean ${property.pluralName}Contains(${property.type} value) {
        return ${property.pluralName}_.contains(value);
    }
#end
#if (${property.isWriteable()})
    ${property.writerAccess}${property.extraMethodKeywords}void add${property.upperName}(${property.type} value) {
        if (value == null) throw new IllegalArgumentException("Cannot add null to ${property.name}");
        ${property.pluralName}_.add(value);
#if (${property.isBound()})
        getPropertyChangeSupport().firePropertyChange("${property.pluralName}", null, ${property.pluralName}_);
#end
    }
    ${property.writerAccess}${property.extraMethodKeywords}void clear${property.upperPluralName}() {
        ${property.pluralName}_.clear();
#if (${property.isBound()})
        getPropertyChangeSupport().firePropertyChange("${property.pluralName}", null, ${property.pluralName}_);
#end
    }
#end

#else
## define map properties
## if (${property.kind.isMap()})
    private ${property.extraFieldKeywords}final java.util.Map<${property.keyType}, ${property.type}> ${property.pluralName}_ = new java.util.HashMap<${property.keyType}, ${property.type}>();
#if (${property.isReadable()})
    ${property.readerAccess}${property.extraMethodKeywords}${property.type} get${property.upperName}(${property.keyType} key) {
        return ${property.pluralName}_.get(key);
    }
    ${property.readerAccess}${property.extraMethodKeywords}java.util.Map<${property.keyType}, ${property.type}> get${property.upperPluralName}() {
        return ${property.kind.prefix}${property.pluralName}_${property.kind.suffix};
    }
    ${property.readerAccess}${property.extraMethodKeywords}boolean ${property.pluralName}ContainsKey(${property.keyType} key) {
        return ${property.pluralName}_.containsKey(key);
    }
    ${property.readerAccess}${property.extraMethodKeywords}boolean ${property.pluralName}ContainsValue(${property.type} value) {
        return ${property.pluralName}_.containsValue(value);
    }
#end    
#if (${property.isWriteable()})
    ${property.writerAccess}${property.extraMethodKeywords}void put${property.upperName}(${property.keyType} key, ${property.type} value) {
        if (key == null) throw new IllegalArgumentException("Cannot put null key in ${property.name}");
        if (value == null) throw new IllegalArgumentException("Cannot put null value in ${property.name}");
        ${property.pluralName}_.put(key, value);
#if (${property.isBound()})
        getPropertyChangeSupport().firePropertyChange("${property.pluralName}", null, ${property.pluralName}_);
#end    
    }
    ${property.writerAccess}${property.extraMethodKeywords}void clear${property.upperPluralName}() {
        ${property.pluralName}_.clear();
#if (${property.isBound()})
        getPropertyChangeSupport().firePropertyChange("${property.pluralName}", null, ${property.pluralName}_);
#end
    }
#end    
#end
#end

##
## Define default methods
##
#foreach ($defaultMethod in ${data.defaultMethods})
    ${defaultMethod.access}${defaultMethod.abstractQualifier}${defaultMethod.returnType} ${defaultMethod.name}(${defaultMethod.argDecls})${defaultMethod.throwsClause} ${defaultMethod.symbolAfterDecl}
#if (!${defaultMethod.isAbstract()})
        ${defaultMethod.returnOrNot}${defaultMethod.name}(${defaultMethod.args});
    }
#end
#end
##
## Define delegate methods
##
#foreach ($delegate in ${data.delegates})
##    private ${delegate.type} ${$delegate.field}_;
#foreach ($delegateMethod in ${delegate.methods})
#if (${delegate.isOverriding()})
    @Override
#end
    public ${delegateMethod.returnType} ${delegateMethod.name}(${delegateMethod.argDecls})${delegateMethod.throwsClause} {
        ${delegateMethod.returnOrNot}${delegate.accessor}.${delegateMethod.name}(${delegateMethod.args});
    }
#end
#end
##
## Define null-object implementation methods
##
#foreach ($nullImplementation in ${data.nullImplementations})
#foreach ($nullMethod in ${nullImplementation.methods})
#if (${nullImplementation.isOverriding()})
    @Override
#end
    public ${nullMethod.returnType} ${nullMethod.name}(${nullMethod.argDecls})${nullMethod.throwsClause} {
        ${nullMethod.nullBody}
    }
#end
#end
##
## Define event-set management/fire methods
## TODO - what if the methods are declared to throw exceptions (like PropertyVetoException)?
##
#foreach ($listener in ${data.listeners})
    private java.util.List<${listener.name}> ${listener.lowerName}s_ = new java.util.ArrayList<${listener.name}>();
    public void add${listener.nameWithoutPackage}(${listener.name} listener) {
        synchronized(${listener.lowerName}s_) {
            ${listener.lowerName}s_.add(listener);
        }
    }
    public void remove${listener.nameWithoutPackage}(${listener.name} listener) {
        synchronized(${listener.lowerName}s_) {
            ${listener.lowerName}s_.remove(listener);
        }
    }
#foreach ($listenerMethod in $listener.methods)
    protected void fire${listenerMethod.upperName}(${listenerMethod.argDecls}) {
        java.util.List<${listener.name}> targets = null;
        synchronized(${listener.lowerName}s_) {
            targets = new java.util.ArrayList<${listener.name}>(${listener.lowerName}s_);
        }
        for (${listener.name} listener : targets) {
            listener.${listenerMethod.name}(${listenerMethod.args});
        }
    }
#end
#end
##
## Define simple equals() and hashCode() methods
##
#if (${data.isDefineSimpleEqualsAndHashCode()})
    protected boolean checkEquals(java.lang.Object o1, java.lang.Object o2) {
        if (o1 == o2) {
            return true;
        }
        if (o1 == null || o2 == null) {
            return false;
        }
        return o1.equals(o2);
    }

    @Override
    public boolean equals(java.lang.Object obj) {
        if (obj == this) {
            return true;
        }
#if (${data.isEqualsShouldCheckSuperEquals()})
        if (obj == null || obj.getClass() != getClass() || !super.equals(obj)) {
#else
        if (obj == null || obj.getClass() != getClass()) {
#end
            return false;
        }
        ${data.className}Gen other = (${data.className}Gen) obj;
        return
#set ($last = ${data.properties.size()})
#set ($current = 0)
#set ($op = " &&")
#foreach ($property in ${data.properties})
#set ($current = $current + 1)
#if ($current == $last)
#set ($op = ";")
#end
#if (${property.kind.isSimple()})
#if (${property.isPrimitive()})
            other.${property.name}_ == ${property.name}_${op}
#else
            checkEquals(other.${property.name}_, ${property.name}_)${op}
#end
#else
            checkEquals(other.${property.pluralName}_, ${property.pluralName}_)${op}
#end
#end
    }
    @Override
    public int hashCode() {
        return super.hashCode() +
#set ($last = ${data.properties.size()})
#set ($current = 0)
#set ($op = " +")
#foreach ($property in ${data.properties})
#set ($current = $current + 1)
#if ($current == $last)
#set ($op = ";")
#end
#if (${property.kind.isSimple()})
            ${property.intConversion}${op}
#else
            ${property.pluralName}_.hashCode()${op}
#end
#end
    }
#end
##
## Define a nice default toString method
##
    @Override
    public java.lang.String toString() {
        return getClass().getName() + '[' + paramString() + ']';
    }
#if (${data.isParamStringOverridden()})
    @Override
#end
    protected java.lang.String paramString() {
#if (${data.properties.isEmpty()})
        return "";
#else
        return 
#set ($last = ${data.properties.size()})
#set ($current = 0)
#set ($op = " +")
#set ($comma = "")
#foreach ($property in ${data.properties})
#set ($current = $current + 1)
#if ($current == $last)
#set ($op = ";")
#end
#if (!${property.omitFromToString})
#if (${property.kind.isSimple()})
               "${comma}${property.name}=" + ${property.name}_${op}
#else
               "${comma}${property.pluralName}=" + ${property.pluralName}_${op}
#end
#set ($comma = ",")
#end
#end
#end
    }
#if (${data.isCreatePropertyMap()})
    public java.util.Map<java.lang.String, java.lang.Object> createPropertyMap() {
                    java.util.Map<java.lang.String, java.lang.Object> map = new java.util.HashMap<java.lang.String, java.lang.Object>();
#foreach ($property in ${data.properties})
#if (${property.isReadable()})
#if (${property.kind.isSimple()})
                    map.put("${property.name}", ${property.isGet()}${property.upperName}());
        #else
                    map.put("${property.pluralName}", ${property.isGet()}${property.upperPluralName}());
#end
#end
#end
        return map;
    }
#end
}
